{"ast":null,"code":"// HeapSort.js\nexport function heapSort(array){const animations=[];// Build the max heap\nconst buildMaxHeap=()=>{const n=array.length;for(let i=Math.floor(n/2)-1;i>=0;i--){heapify(n,i);}};// Heapify a subtree rooted with node i\nconst heapify=(n,i)=>{let largest=i;const left=2*i+1;const right=2*i+2;if(left<n&&array[left]>array[largest]){largest=left;}if(right<n&&array[right]>array[largest]){largest=right;}if(largest!==i){// Push animations for comparison and swapping\nanimations.push([i,largest,false]);// Comparison\nanimations.push([i,largest,true]);// Swapping\n[array[i],array[largest]]=[array[largest],array[i]];heapify(n,largest);}};// Perform Heap Sort\nbuildMaxHeap();for(let i=array.length-1;i>0;i--){// Swap root (max element) with the last element\nanimations.push([0,i,true]);[array[0],array[i]]=[array[i],array[0]];// Heapify the reduced heap\nheapify(i,0);}return animations;}","map":{"version":3,"names":["heapSort","array","animations","buildMaxHeap","n","length","i","Math","floor","heapify","largest","left","right","push"],"sources":["D:/Project/sorting_visualizer/src/Algorithms/HeapSort.js"],"sourcesContent":["// HeapSort.js\r\nexport function heapSort(array) {\r\n  const animations = [];\r\n\r\n  // Build the max heap\r\n  const buildMaxHeap = () => {\r\n    const n = array.length;\r\n    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {\r\n      heapify(n, i);\r\n    }\r\n  };\r\n\r\n  // Heapify a subtree rooted with node i\r\n  const heapify = (n, i) => {\r\n    let largest = i;\r\n    const left = 2 * i + 1;\r\n    const right = 2 * i + 2;\r\n\r\n    if (left < n && array[left] > array[largest]) {\r\n      largest = left;\r\n    }\r\n\r\n    if (right < n && array[right] > array[largest]) {\r\n      largest = right;\r\n    }\r\n\r\n    if (largest !== i) {\r\n      // Push animations for comparison and swapping\r\n      animations.push([i, largest, false]); // Comparison\r\n      animations.push([i, largest, true]);  // Swapping\r\n      [array[i], array[largest]] = [array[largest], array[i]];\r\n      heapify(n, largest);\r\n    }\r\n  };\r\n\r\n  // Perform Heap Sort\r\n  buildMaxHeap();\r\n  for (let i = array.length - 1; i > 0; i--) {\r\n    // Swap root (max element) with the last element\r\n    animations.push([0, i, true]);\r\n    [array[0], array[i]] = [array[i], array[0]];\r\n\r\n    // Heapify the reduced heap\r\n    heapify(i, 0);\r\n  }\r\n\r\n  return animations;\r\n}\r\n"],"mappings":"AAAA;AACA,MAAO,SAAS,CAAAA,QAAQA,CAACC,KAAK,CAAE,CAC9B,KAAM,CAAAC,UAAU,CAAG,EAAE,CAErB;AACA,KAAM,CAAAC,YAAY,CAAGA,CAAA,GAAM,CACzB,KAAM,CAAAC,CAAC,CAAGH,KAAK,CAACI,MAAM,CACtB,IAAK,GAAI,CAAAC,CAAC,CAAGC,IAAI,CAACC,KAAK,CAACJ,CAAC,CAAG,CAAC,CAAC,CAAG,CAAC,CAAEE,CAAC,EAAI,CAAC,CAAEA,CAAC,EAAE,CAAE,CAC/CG,OAAO,CAACL,CAAC,CAAEE,CAAC,CAAC,CACf,CACF,CAAC,CAED;AACA,KAAM,CAAAG,OAAO,CAAGA,CAACL,CAAC,CAAEE,CAAC,GAAK,CACxB,GAAI,CAAAI,OAAO,CAAGJ,CAAC,CACf,KAAM,CAAAK,IAAI,CAAG,CAAC,CAAGL,CAAC,CAAG,CAAC,CACtB,KAAM,CAAAM,KAAK,CAAG,CAAC,CAAGN,CAAC,CAAG,CAAC,CAEvB,GAAIK,IAAI,CAAGP,CAAC,EAAIH,KAAK,CAACU,IAAI,CAAC,CAAGV,KAAK,CAACS,OAAO,CAAC,CAAE,CAC5CA,OAAO,CAAGC,IAAI,CAChB,CAEA,GAAIC,KAAK,CAAGR,CAAC,EAAIH,KAAK,CAACW,KAAK,CAAC,CAAGX,KAAK,CAACS,OAAO,CAAC,CAAE,CAC9CA,OAAO,CAAGE,KAAK,CACjB,CAEA,GAAIF,OAAO,GAAKJ,CAAC,CAAE,CACjB;AACAJ,UAAU,CAACW,IAAI,CAAC,CAACP,CAAC,CAAEI,OAAO,CAAE,KAAK,CAAC,CAAC,CAAE;AACtCR,UAAU,CAACW,IAAI,CAAC,CAACP,CAAC,CAAEI,OAAO,CAAE,IAAI,CAAC,CAAC,CAAG;AACtC,CAACT,KAAK,CAACK,CAAC,CAAC,CAAEL,KAAK,CAACS,OAAO,CAAC,CAAC,CAAG,CAACT,KAAK,CAACS,OAAO,CAAC,CAAET,KAAK,CAACK,CAAC,CAAC,CAAC,CACvDG,OAAO,CAACL,CAAC,CAAEM,OAAO,CAAC,CACrB,CACF,CAAC,CAED;AACAP,YAAY,CAAC,CAAC,CACd,IAAK,GAAI,CAAAG,CAAC,CAAGL,KAAK,CAACI,MAAM,CAAG,CAAC,CAAEC,CAAC,CAAG,CAAC,CAAEA,CAAC,EAAE,CAAE,CACzC;AACAJ,UAAU,CAACW,IAAI,CAAC,CAAC,CAAC,CAAEP,CAAC,CAAE,IAAI,CAAC,CAAC,CAC7B,CAACL,KAAK,CAAC,CAAC,CAAC,CAAEA,KAAK,CAACK,CAAC,CAAC,CAAC,CAAG,CAACL,KAAK,CAACK,CAAC,CAAC,CAAEL,KAAK,CAAC,CAAC,CAAC,CAAC,CAE3C;AACAQ,OAAO,CAACH,CAAC,CAAE,CAAC,CAAC,CACf,CAEA,MAAO,CAAAJ,UAAU,CACnB"},"metadata":{},"sourceType":"module","externalDependencies":[]}